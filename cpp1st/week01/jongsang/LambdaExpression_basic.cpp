// LambdaExpression_basic.cpp : Various lambda expression //

#include <iostream>
#include <thread>
#include <vector>
#include <string>


/// <summary>
/// Lambda basic test 0
/// Understand the lambda operation based on function object
/// </summary>

class AutoGeneratedLambda0
{
public:
	auto operator() () const
	{
		std::wcout << L"Hello, this is by function object" << std::endl;
	}
};

void test_basicLambda0(void)
{
	//It must be well understood that the lambda expression is actually
	//a class.In order to call it, the compiler needs to instantiate an object
	//of the class.The object instantiated from a lambda expression is
	//called a lambda closure. - Modern C++ Programming Cookbook -

	std::wcout << L"====" << __FUNCTIONW__ << L"====" << std::endl;
	
	auto basicLambda0 = [] {std::wcout << L"Hello, this is by lambda expression" << std::endl; };
	basicLambda0();
	
	AutoGeneratedLambda0 basicLambdaFuntionObj;
	basicLambdaFuntionObj();

}
// =====================================================================================================

/// <summary>
/// Lambda basic test 1
/// Understand the parameter of lambda expression based on function object
/// </summary>

class AutoGeneratedLambda1
{
public:
	auto operator() (std::wstring name) const
	{
		std::wcout << L"My name is : " << name << std::endl;
	}
};

void test_basicLambda1(void)
{
	std::wcout << L"====" << __FUNCTIONW__ << L"====" << std::endl;

	auto basicLambda1 = [](std::wstring name) {std::wcout << L"My name is : " << name << std::endl; };
	basicLambda1(L"jongsang");

	AutoGeneratedLambda1 basicLambdaFuntionObj;
	basicLambdaFuntionObj(L"jongsang");

}
// =====================================================================================================

/// <summary>
/// Lambda basic test 2
/// Understand "capture by value" of lambda expression based on function object
/// </summary>
class AutoGeneratedLambda2
{
public:
	// constructor
	AutoGeneratedLambda2(const double& d) : data(d) {}
	auto operator() () const
	{
		std::wcout << L"The data is " << data << std::endl;
	}
private:
	// non-const data member
	double data;
};

void test_basicLambda2(void)
{
	std::wcout << L"====" << __FUNCTIONW__ << L"====" << std::endl;

	double data = 3.14159;
	auto basicLambda2 = [data]() {std::wcout << L"The data is " << data << std::endl; };
	basicLambda2();

	AutoGeneratedLambda2 basicLambdaFuntionObj(data);
	basicLambdaFuntionObj();
}
// =====================================================================================================

/// <summary>
/// Lambda basic test 3
/// Understand "mutable" of lambda expression based on function object
/// </summary>
class AutoGeneratedLambda3
{
public:
	// constructor
	AutoGeneratedLambda3(const double& d) : data(d) {}
	auto operator() ()
	{
		data *= 10;
		std::wcout << L"(FunctionObj) The data is " << data << std::endl;
	}
private:
	// non-const data member
	double data;
};

void test_basicLambda3(void)
{
	std::wcout << L"====" << __FUNCTIONW__ << L"====" << std::endl;

	double data = 3.14159;
	auto basicLambda3 = [data]() mutable {
		data *= 10;
		std::wcout << L"(Lambda) The data is " << data << std::endl; };
	basicLambda3();

	AutoGeneratedLambda3 basicLambdaFuntionObj(data);
	basicLambdaFuntionObj();
}
// =====================================================================================================

/// <summary>
/// Lambda basic test 4
/// Understand "capture by reference" of lambda expression based on function object
/// </summary>
class AutoGeneratedLambda4
{
public:
	// constructor
	AutoGeneratedLambda4(double& d) : data(d) {}
	auto operator() () const
	{
		data *= 10;
		std::wcout << L"(FunctionObj) The data is " << data << std::endl;
	}
private:
	// non-const data member
	double& data;
};

void test_basicLambda4(void)
{
	std::wcout << L"====" << __FUNCTIONW__ << L"====" << std::endl;

	double data0 = 3.14159;
	auto basicLambda4 = [&data0]() {
		data0 *= 10;
		std::wcout << L"(Lambda) The data is " << data0 << std::endl; };
	basicLambda4();
	std::wcout << L"(Original) The data is " << data0 << std::endl;

	double data1 = 3.14159;
	AutoGeneratedLambda4 basicLambdaFuntionObj(data1);
	basicLambdaFuntionObj();
	std::wcout << L"(Original) The data is " << data1 << std::endl;
}
// =====================================================================================================

/// <summary>
/// Lambda basic test 5
/// Understand the generic lambda expression based on function object
/// </summary>
class AutoGeneratedGenericLambda
{
public:
	template <typename T>
	auto operator() (const T& value) const
	{
		return value > 50 && value < 100;
	}
};

void test_GenericLambda()
{
	std::wcout << L"====" << __FUNCTIONW__ << L"====" << std::endl;

	auto genericLambda = [](const auto& val) {
		return val > 50 && val < 100;
	};

	std::vector<int> vecInt{ 34, 56, 22, 11, 65, 120 };
	auto iter1 = std::find_if(vecInt.begin(), vecInt.end(), genericLambda);
	if (iter1 != vecInt.end())
	{
		std::wcout << L"(Lambda) The int value is found : " << *iter1 << std::endl;
	}

	std::vector<double> vecDouble{ 12.3, 43.12, 55.5, 11.6, 63.6 };
	auto iter2 = std::find_if(vecDouble.begin(), vecDouble.end(), genericLambda);
	if (iter2 != vecDouble.end())
	{
		std::wcout << L"(Lambda) The double value is found : " << *iter2 << std::endl;
	}

	AutoGeneratedGenericLambda functionObj;
	auto iter3 = std::find_if(vecInt.begin(), vecInt.end(), functionObj);
	if (iter3 != vecInt.end())
	{
		std::wcout << L"(FunctionObj) The int value is found : " << *iter3 << std::endl;
	}
	
	auto iter4 = std::find_if(vecDouble.begin(), vecDouble.end(), functionObj);
	if (iter4 != vecDouble.end())
	{
		std::wcout << L"(FunctionObj) The double value is found : " << *iter4 << std::endl;
	}

}


int main()
{
	test_basicLambda0();
	test_basicLambda1();
	test_basicLambda2();
	test_basicLambda3();
	test_basicLambda4();
	test_GenericLambda();

	return 0;
}

